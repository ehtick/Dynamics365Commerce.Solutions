/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import {
    AddToCartComponent,
    AddToOrderTemplateComponent,
    AddToWishlistComponent,
    IAddToCartFailureResult,
    IAddToCartResources,
    IAddToOrderTemplateDialogResources,
    IDuplicateItemsWhenAddingToOrderTemplateDialogResources,
    IItemAddedToOrderTemplateDialogResources,
    IOrderTemplateActionErrorResult,
    IOrderTemplateNameDialogResources,
    IWishlistActionErrorResult,
    RatingComponent
} from '@msdyn365-commerce/components';
import { getUrlSync, IImageSettings } from '@msdyn365-commerce/core';
import { ICartActionResult, ICartState } from '@msdyn365-commerce/global-state';
import { ProductAvailableQuantity, SimpleProduct, ProductDimension } from '@msdyn365-commerce/retail-proxy';
import { ArrayExtensions, DeliveryMode } from '@msdyn365-commerce-modules/retail-actions';
import {
    Alert,
    Button,
    format,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    Heading,
    ITelemetryContent,
    Node,
    Quantity,
    TelemetryConstant
} from '@msdyn365-commerce-modules/utilities';
import * as React from 'react';

import {
    IBuyboxAddToCartViewProps,
    IBuyboxAddToOrderTemplateViewProps,
    IBuyboxAddToWishlistViewProps,
    IBuyboxCallbacks,
    IBuyboxCommonData,
    IBuyboxCommonResources,
    IBuyboxErrorBlockProps,
    IBuyboxExtentedProps,
    IBuyboxKeyInPriceViewProps,
    IBuyboxProductQuantityViewProps,
    IBuyboxShopSimilarLookViewProps,
    IBuyboxState,
    IProductDetails,
    ShopSimiliarButtonType
} from './buyboxInterface';
import { getConfigureErrors, getGenericError, getQuantityError } from './utilities/error-utilities';
import { IKitBuyboxData } from '../modules/kit-buybox/kit-buybox.data';
import { IKitBuyboxProps } from '../modules/kit-buybox/kit-buybox.props.autogenerated';
import { PriceComponent } from '../../src/themes/fabrikam-extended/views/components/price.component';

const _getClassNamePrefix = (typeName: string): string => {
    return typeName.toLocaleLowerCase() === 'quickview' ? 'ms-quickView' : 'ms-buybox';
};

export function getBuyBoxInventoryLabel(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    productDetails?: IProductDetails
): React.ReactElement | undefined {
    const { typeName } = props;

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const productAvailableQuantity = props.data.productAvailableQuantity?.result ?? productDetails?.productAvailableQuantity;

    const className = _getClassNamePrefix(typeName);
    if (!productAvailableQuantity || !ArrayExtensions.hasElements(productAvailableQuantity)) {
        return undefined;
    }
    const shippingInventory = productAvailableQuantity.find(shipping => shipping.deliveryType === DeliveryMode.shipping);

    if (shippingInventory) {
        let inventoryClassName: string;
        if (shippingInventory.StockLevelCode) {
            inventoryClassName = `${className}__inventory-label ${className}__inventory-code-${shippingInventory.StockLevelCode.toLowerCase()}`;
        } else {
            inventoryClassName = `${className}__inventory-label`;
        }
        return (
            <div className={`${className}__inventory-info`}>
                <span className={inventoryClassName}>{shippingInventory.StockLevelLabel}</span>
            </div>
        );
    }

    return undefined;
}

export function getBuyboxProductTitle(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    productDetails?: IProductDetails
): React.ReactElement | undefined {
    const {
        config: { titleHeadingTag = 'h1' },
        typeName
    } = props;
    const className = _getClassNamePrefix(typeName);

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const product = props.data.product?.result ?? productDetails?.product ?? undefined;

    return product && <Heading className={`${className}__product-title`} headingTag={titleHeadingTag} text={product.Name ?? ''} />;
}

export function getBuyboxProductDescription(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    productDetails?: IProductDetails
): React.ReactElement | undefined {
    const { typeName } = props;
    const className = _getClassNamePrefix(typeName);

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const product = props.data.product?.result ?? productDetails?.product ?? undefined;

    return product && <p className={`${className}__product-description`}>{product.Description}</p>;
}

/**
 * Gets the react node for product unit of measure display.
 * @param {IBuyboxExtentedProps<IBuyboxCommonData>} props The buybox module props.
 * @param {IProductDetails} productDetails The product details to be displyed in buybox.
 * @returns {React.ReactElement} The node representing markup for unit of measure component.
 */
export function getBuyboxProductUnitOfMeasure(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    productDetails?: IProductDetails
): React.ReactElement | undefined {
    const { typeName } = props;
    const className = _getClassNamePrefix(typeName);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- Do not need type check for appsettings
    if (
        props.context.app.config &&
        (!props.context.app.config.unitOfMeasureDisplayType || props.context.app.config.unitOfMeasureDisplayType === 'none')
    ) {
        return undefined;
    }

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const product = props.data.product?.result ?? productDetails?.product;
    if (!product || !product.DefaultUnitOfMeasure) {
        props.telemetry.warning('Missing defult unit of measureor theproduct');
        return undefined;
    }

    return (
        <div className={`${className}__product-unit-of-measure`}>
            <span>{product.DefaultUnitOfMeasure}</span>
        </div>
    );
}

let telemetryContent: ITelemetryContent;

/**
 * On add to cart failed function.
 * @param props -The buybox module props.
 * @param state -The buybox module state.
 * @param callbacks -The buybox module callbacks.
 * @param defaultMinimumKeyInPrice -The default minimum key in price.
 * @param defaultMaximumKeyInPrice -The default maximum key in price.
 * @param cart -The cart state.
 * @param product -The simple product.
 * @param productAvailability -The product available quantity.
 * @returns Update error state.
 */
const onAddToCartFailed = (
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks,
    defaultMinimumKeyInPrice: number,
    defaultMaximumKeyInPrice: number,
    cart: ICartState,
    product: SimpleProduct,
    productAvailability: ProductAvailableQuantity | undefined
) => (result: IAddToCartFailureResult) => {
    let quantityErrorForState: string | undefined;
    let customAmountErrorForState: string | undefined;
    let otherErrorForState: string | undefined = getGenericError(
        result,
        cart,
        props.resources,
        props.context,
        product,
        productAvailability,
        undefined
    );

    if (result.failureReason === 'OUTOFSTOCK') {
        quantityErrorForState = result.failureReason === 'OUTOFSTOCK' ? getQuantityError(result.stockLeft, props.resources) : undefined;
    } else if (
        result.failureReason === 'CARTACTIONFAILED' &&
        result.cartActionResult &&
        (result.cartActionResult.substatus === 'MAXQUANTITY' || result.cartActionResult.substatus === 'QUANTITYLIMITS')
    ) {
        quantityErrorForState = getGenericError(result, cart, props.resources, props.context, product, productAvailability, undefined);
        otherErrorForState = undefined; // Prevent error duplication in otherError and quantityError
    }

    if (result.failureReason === 'INVALIDCUSTOMAMOUNT') {
        if (state.keyInPriceAmount === undefined || state.keyInPriceAmount < (props.config.minimumKeyInPrice || defaultMinimumKeyInPrice)) {
            const formatedAmountLimit = props.context.cultureFormatter.formatCurrency(
                props.config.minimumKeyInPrice || defaultMinimumKeyInPrice
            );
            customAmountErrorForState = props.resources.invalidSmallCustomAmountText.replace('{minAmount}', formatedAmountLimit);
        } else if (state.keyInPriceAmount > (props.config.maximumKeyInPrice || defaultMaximumKeyInPrice)) {
            const formatedAmountLimit = props.context.cultureFormatter.formatCurrency(
                props.config.maximumKeyInPrice || defaultMaximumKeyInPrice
            );
            customAmountErrorForState = props.resources.invalidLargeCustomAmountText.replace('{maxAmount}', formatedAmountLimit);
        }
    }

    callbacks.updateErrorState({
        errorHost: 'ADDTOCART',
        quantityError: quantityErrorForState,
        configureErrors:
            result.failureReason === 'MISSINGDIMENSION'
                ? getConfigureErrors(result.missingDimensions, props.resources, product?.IsGiftCard)
                : {},
        customAmountError: customAmountErrorForState,
        otherError: otherErrorForState
    });
};

/**
 * On Item Add To Cart function.
 * @param typeName -Type name.
 * @param callbacks -Buybox Callbacks.
 * @returns Change modal open.
 */
const onItemAddedToCart = (typeName: string, callbacks: IBuyboxCallbacks) => (result: ICartActionResult) => {
    if (typeName === 'quickview') {
        callbacks.changeModalOpen(false);
    }
};

export function getBuyboxAddToCart(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks,
    defaultMinimumKeyInPrice: number,
    defaultMaximumKeyInPrice: number,
    kitVariantRecordId: number | undefined,
    productDetails?: IProductDetails,
    hasAvailableProducts?: boolean
): IBuyboxAddToCartViewProps {
    const { id, typeName, context, resources } = props;

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const product = props.data.product?.result ?? productDetails?.product;

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const cart = props.data.cart?.result ?? productDetails?.cart;

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const productAvailableQuantity = props.data.productAvailableQuantity?.result ?? productDetails?.productAvailableQuantity;

    const {
        quantity,
        errorState: { configureErrors, quantityError, customAmountError, otherError, errorHost },
        selectedProduct,
        isUpdatingDimension,
        isUpdatingDeliveryOptions,
        isServiceItem
    } = state;

    const productAvailability = state.productAvailableQuantity
        ? state.productAvailableQuantity.ProductAvailableQuantity
        : productAvailableQuantity && productAvailableQuantity.length > 0
        ? productAvailableQuantity[0].ProductAvailableQuantity
        : undefined;

    const dialogStrings: IAddToCartResources = {
        goToCartText: resources.buyBoxGoToCartText,
        continueShoppingText: resources.buyBoxContinueShoppingText,
        closeNotificationLabel: resources.closeNotificationLabel,
        headerItemOneText: resources.buyBoxSingleItemText,
        headerItemFormatText: resources.buyBoxMultiLineItemFormatText,
        headerMessageText: resources.buyBoxHeaderMessageText,
        freePriceText: resources.priceFree,
        originalPriceText: resources.originalPriceText,
        currentPriceText: resources.currentPriceText,
        addedQuantityText: resources.addedQuantityText
    };

    const defaultImageSettings: IImageSettings = {
        viewports: {
            xs: { q: 'w=240&h=240&m=6', w: 0, h: 0 },
            lg: { q: 'w=240&h=240&m=6', w: 0, h: 0 },
            xl: { q: 'w=240&h=240&m=6', w: 0, h: 0 }
        },
        lazyload: true
    };

    const isProductQuantityLoading = typeName !== 'quickview' && props.data.productAvailableQuantity.status === 'LOADING';
    if (isProductQuantityLoading) {
        callbacks.changeUpdatingDimension(false);
    }

    const isLoadingDeliveryOptions = typeName !== 'quickview' && props.data.deliveryOptions?.status === 'LOADING';
    if (isLoadingDeliveryOptions && callbacks.changeUpdatingDeliveryOptions) {
        callbacks.changeUpdatingDeliveryOptions(false);
    }

    telemetryContent = getTelemetryObject(props.context.request.telemetryPageName!, props.typeName, props.telemetry);

    // Check if the product delivery mode is electronic
    const emailDeliveryModeCode = props.context.actionContext.requestContext.channel?.EmailDeliveryModeCode;
    const deliveryOptions = props.data.deliveryOptions?.result;
    const isEmailDelivery =
        ArrayExtensions.hasElements(deliveryOptions?.DeliveryOptions) && deliveryOptions!.DeliveryOptions[0].Code === emailDeliveryModeCode;
    const className = _getClassNamePrefix(typeName);
    const isDisabled = isUpdatingDimension && typeName === 'quickview';

    if (product && kitVariantRecordId && kitVariantRecordId !== -1) {
        props.context.app.config.enableStockCheck = false;
        product.RecordId = kitVariantRecordId;
    }

    return {
        ContainerProps: {
            className: `${className}__add-to-cart-container`
        },
        button: product && (
            <AddToCartComponent
                addToCartText={resources.addToCartText}
                outOfStockText={resources.outOfStockText}
                navigationUrl={getUrlSync('cart', context.actionContext)}
                quantity={quantity}
                data={{ product, price: state.productPrice }}
                context={context}
                disabled={isDisabled}
                id={id}
                hasAvailableProducts={hasAvailableProducts}
                typeName={typeName}
                onError={onAddToCartFailed(
                    props,
                    state,
                    callbacks,
                    defaultMinimumKeyInPrice,
                    defaultMaximumKeyInPrice,
                    cart!,
                    product,
                    productAvailability
                )}
                getSelectedProduct={selectedProduct}
                productAvailability={productAvailability}
                isProductQuantityLoading={isProductQuantityLoading}
                isUpdatingDimension={isUpdatingDimension}
                changeUpdatingDimension={callbacks.changeUpdatingDimension}
                isLoadingDeliveryOptions={isLoadingDeliveryOptions}
                isUpdatingDeliveryOptions={isUpdatingDeliveryOptions}
                changeUpdatingDeliveryOptions={callbacks.changeUpdatingDeliveryOptions}
                dialogStrings={dialogStrings}
                gridSettings={props.context.request.gridSettings}
                imageSettings={defaultImageSettings}
                telemetryContent={telemetryContent}
                isAddServiceItemToCart={isServiceItem}
                isPriceKeyedIn={state.isPriceKeyedIn}
                customPriceAmount={state.keyInPriceAmount}
                isCustomPriceSelected={state.isCustomPriceSelected}
                maximumKeyInPrice={props.config.maximumKeyInPrice}
                minimumKeyInPrice={props.config.minimumKeyInPrice}
                defaultMinimumKeyInPrice={defaultMinimumKeyInPrice}
                defaultMaximumKeyInPrice={defaultMaximumKeyInPrice}
                isOrderQuantityLimitsFeatureEnabled={_isOrderQuantityLimitsFeatureEnabled(props)}
                isAddEmailDeliveryItemToCart={isEmailDelivery}
                onAdd={onItemAddedToCart(typeName, callbacks)}
                isNavigationToCartPageDisabled={typeName === 'quickview'}
            />
        ),
        errorBlock: (
            <BuyboxErrorBlock
                configureErrors={configureErrors}
                quantityError={quantityError}
                customAmountError={customAmountError}
                otherError={otherError}
                resources={resources}
                showError={errorHost === 'ADDTOCART'}
            />
        )
    };
}

/**
 * Get the React.ReactElement contains price.
 * @param props - The IBuyboxExtentedProps.
 * @param state - The buybox state.
 * @returns The React.ReactElement.
 */
export function getBuyboxProductPrice(props: IBuyboxExtentedProps<IBuyboxCommonData>, state: IBuyboxState): React.ReactElement | undefined {
    const { id, typeName, context, resources } = props;

    return (
        state.productPrice && (
            <PriceComponent
                id={id}
                typeName={typeName}
                context={context}
                data={{ price: state.productPrice }}
                isPriceMinMaxEnabled={
                    props.data.featureState.result?.find(
                        featureState => featureState.Name === 'Dynamics.AX.Application.RetailSearchPriceRangeFeature'
                    )?.IsEnabled
                }
                isSalesAgreementPriceFeatureEnabled={
                    props.data.featureState.result?.find(
                        featureState => featureState.Name === 'Dynamics.AX.Application.RetailSalesAgreementPriceSupportFeature'
                    )?.IsEnabled
                }
                priceResources={{
                    priceRangeSeparator: resources.priceRangeSeparator,
                    salesAgreementPricePrompt: resources.salesAgreementPricePrompt,
                    salesAgreementExpirationDatePrompt: resources.salesAgreementExpirationDatePrompt,
                    salesAgreementCommittedQuantityPrompt: resources.salesAgreementCommittedQuantityPrompt,
                    salesAgreementRemainingQuantityPrompt: resources.salesAgreementRemainingQuantityPrompt
                }}
                freePriceText={resources.priceFree}
                originalPriceText={resources.originalPriceText}
                currentPriceText={resources.currentPriceText}
            />
        )
    );
}

export function getBuyboxProductRating(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    productDetails?: IProductDetails
): React.ReactElement | undefined {
    const { id, typeName, context, resources } = props;

    // Since the data action can return no value, and the type is non-nullable due to backward compatibility reasons, the null check is required.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
    const ratingsSummary = props.data.ratingsSummary?.result ?? productDetails?.ratingsSummary;
    if (!ratingsSummary || !ratingsSummary.averageRating) {
        return <div />;
    }
    const ratingComponent = (
        <RatingComponent
            avgRating={ratingsSummary.averageRating || 0}
            readOnly
            ariaLabel={format(resources.averageRatingAriaLabel, ratingsSummary.averageRating, '5')}
            ratingCount={`${ratingsSummary.reviewsCount}`}
            data={{}}
            context={context}
            id={id}
            typeName={typeName}
        />
    );

    return ratingComponent;
}

function generateAddToOrderTemplateDialogResources(resources: IBuyboxCommonResources): IAddToOrderTemplateDialogResources {
    return {
        addToOrderTemplateHeader: resources.addToOrderTemplateHeader,

        noOrderTemplatesMessage: resources.noOrderTemplatesMessage,
        noOrderTemplatesDescription: resources.noOrderTemplatesDescription,

        createAnOrderTemplateButtonText: resources.createAnOrderTemplateButtonText,
        createNewOrderTemplateButtonText: resources.createNewOrderTemplateButtonText,
        cancelOrderTemplateCreationButtonText: resources.cancelOrderTemplateCreationButtonText,

        selectTemplatesText: resources.selectTemplatesText,
        addToTemplateButtonText: resources.addToTemplateButtonText,
        lineItemsText: resources.lineItemsText
    };
}

function generateOrderTemplateNameDialogResources(resources: IBuyboxCommonResources): IOrderTemplateNameDialogResources {
    return {
        orderTemplateHeaderLabel: resources.createOrderTemplateHeader,
        orderTemplateTitleLabel: resources.orderTemplateTitle,
        orderTemplateNameAriaLabel: resources.orderTemplateNameAriaLabel,
        orderTemplateDescription: resources.createOrderTemplateDescription,

        defaultOrderTemplateName: resources.defaultOrderTemplateName,

        orderTemplateButtonLabel: resources.createOrderTemplateButtonText,
        orderTemplateCancelButtonLabel: resources.cancelNewOrderTemplateCreationButtonText
    };
}

function generateItemAddedToOrderTemplateDialogResources(resources: IBuyboxCommonResources): IItemAddedToOrderTemplateDialogResources {
    return {
        viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
        continueShoppingButtonText: resources.continueShoppingButtonText,
        itemAddedToOrderTemplateHeaderItemOneText: resources.itemAddedToOrderTemplateHeaderItemOneText,
        itemAddedToOrderTemplateHeaderItemFormatText: resources.itemAddedToOrderTemplateHeaderItemFormatText,
        itemAddedToOrderTemplateHeaderMessageText: resources.itemAddedToOrderTemplateHeaderMessageText,
        freePriceText: resources.priceFree,
        originalPriceText: resources.originalPriceText,
        currentPriceText: resources.currentPriceText
    };
}

function generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
    resources: IBuyboxCommonResources
): IDuplicateItemsWhenAddingToOrderTemplateDialogResources {
    return {
        duplicatedProductsHeader: resources.duplicatedProductsHeader,
        duplicatedProductsDescription: resources.duplicatedProductsDescription,
        updateQuantityButtonText: resources.updateQuantityButtonText,
        cancelDuplicateItemsButtonText: resources.cancelDuplicateItemsButtonText
    };
}

/**
 * Add to order template failed function.
 * @param callbacks -Buybox callbacks.
 * @param resources -Buybox common resources.
 * @param product -Simple product.
 * @returns Update error state.
 */
const onAddToOrderTemplateFailed = (callbacks: IBuyboxCallbacks, resources: IBuyboxCommonResources, product: SimpleProduct | undefined) => (
    result: IOrderTemplateActionErrorResult
) => {
    callbacks.updateErrorState({
        errorHost: 'ORDER_TEMPLATE',
        configureErrors:
            result.status === 'MISSING_DIMENSION' ? getConfigureErrors(result.missingDimensions, resources, product?.IsGiftCard) : {}
    });
};

export function getBuyboxProductAddToOrderTemplate(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks
): IBuyboxAddToOrderTemplateViewProps | undefined {
    const {
        id,
        typeName,
        context,
        data: {
            orderTemplates: { result: orderTemplates },
            customerInformation: { result: customerInformation }
        },
        resources
    } = props;

    const product = props.data.product?.result;

    const {
        errorState: { configureErrors, quantityError, customAmountError, otherError, errorHost },
        quantity
    } = state;

    // If custom amount is selected, add-to-orderTemplate is disabled
    if (state.isCustomPriceSelected) {
        return undefined;
    }
    const className = _getClassNamePrefix(typeName);

    return {
        ContainerProps: {
            className: `${className}__add-to-order-template-container`
        },
        button: product && orderTemplates && (
            <AddToOrderTemplateComponent
                className='msc-add-to-cart-extra-actions'
                addToOrderTemplateButtonText={resources.addToOrderTemplateButtonText}
                addToOrderTemplateButtonTooltip={resources.addToOrderTemplateButtonTooltip}
                addToOrderTemplateDialogResources={generateAddToOrderTemplateDialogResources(resources)}
                createOrderTemplateDialogResources={generateOrderTemplateNameDialogResources(resources)}
                itemAddedToOrderTemplateDialogResources={generateItemAddedToOrderTemplateDialogResources(resources)}
                duplicateItemsWhenAddingToOrderTemplateDialogResources={generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
                    resources
                )}
                data={{ product, quantity, orderTemplates, customerInformation }}
                context={context}
                id={id}
                typeName={typeName}
                onError={onAddToOrderTemplateFailed(callbacks, resources, product)}
                shouldShowButtonFailedTooltip={state.isCustomPriceSelected}
            />
        ),
        errorBlock: (
            <BuyboxErrorBlock
                configureErrors={configureErrors}
                quantityError={quantityError}
                customAmountError={customAmountError}
                otherError={otherError}
                resources={resources}
                showError={errorHost === 'ORDER_TEMPLATE'}
            />
        )
    };
}

/**
 * Renders add to comparison button for the given product.
 * @param productComparisonButton - React element of the button.
 * @param product - Product information.
 * @param catalogId - Current catalog.
 * @param state - Buybox state.
 * @returns React element of the button.
 */
export function getBuyboxProductComparisonButton(
    productComparisonButton: React.ReactNode,
    product: SimpleProduct,
    catalogId: number,
    state: IBuyboxState
): JSX.Element | undefined {
    if (state.isCustomPriceSelected) {
        return undefined;
    }

    return React.cloneElement(productComparisonButton as React.ReactElement, { product, catalogId });
}

/**
 * Add to wishlist failed function.
 * @param callbacks -Buybox callbacks.
 * @param resources -Buybox resources.
 * @param product -Simple product.
 * @returns Update error state.
 */
const onAddToWishlistFailed = (callbacks: IBuyboxCallbacks, resources: IBuyboxCommonResources, product: SimpleProduct | undefined) => (
    result: IWishlistActionErrorResult
) => {
    callbacks.updateErrorState({
        errorHost: 'WISHLIST',
        configureErrors:
            result.status === 'MISSINGDIMENSION' ? getConfigureErrors(result.missingDimensions, resources, product?.IsGiftCard) : {}
    });
};

export function getBuyboxProductAddToWishlist(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks,
    productDetails?: IProductDetails
): IBuyboxAddToWishlistViewProps | undefined {
    const {
        id,
        typeName,
        context,
        data: {
            wishlists: { result: wishlists }
        },
        resources
    } = props;

    const product = props.data.product?.result ? props.data.product.result : productDetails?.product;

    const {
        errorState: { configureErrors, quantityError, customAmountError, otherError, errorHost },
        selectedProduct
    } = state;

    // If custom amount is selected, add-to-wishlist is disabled
    if (state.isCustomPriceSelected) {
        return undefined;
    }

    const className = _getClassNamePrefix(typeName);

    return {
        ContainerProps: {
            className: `${className}__add-to-wishlist-container`
        },
        button: product && (
            <AddToWishlistComponent
                className='msc-add-to-cart-extra-actions'
                addToWishlistButtonText={resources.addToWishlistButtonText}
                removeFromWishlistButtonText={resources.removeFromWishlistButtonText}
                addToWishlistMessage={resources.addToWishlistMessage}
                removedFromWishlistMessage={resources.removedFromWishlistMessage}
                addItemToWishlistError={resources.addItemToWishlistError}
                removeItemFromWishlistError={resources.removeItemFromWishlistError}
                nameOfWishlist={resources.nameOfWishlist}
                data={{ product, wishlists }}
                context={context}
                id={id}
                ariaRole='button'
                typeName={typeName}
                onError={onAddToWishlistFailed(callbacks, resources, product)}
                getSelectedProduct={selectedProduct}
            />
        ),
        errorBlock: (
            <BuyboxErrorBlock
                configureErrors={configureErrors}
                quantityError={quantityError}
                customAmountError={customAmountError}
                otherError={otherError}
                resources={resources}
                showError={errorHost === 'WISHLIST'}
            />
        )
    };
}

/**
 * On quantity change function.
 * @param callbacks -Buybox callbacks.
 * @returns Update quantity.
 */
const onQuantityChangeHandler = (callbacks: IBuyboxCallbacks) => (newValue: number) => {
    if (callbacks.updateQuantity) {
        callbacks.updateQuantity(newValue);
    }
};

export function getBuyboxProductQuantity(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks
): IBuyboxProductQuantityViewProps {
    const { resources, typeName } = props;

    const {
        quantity,
        max,
        errorState: { quantityError }
    } = state;

    const className = _getClassNamePrefix(typeName);

    return {
        ContainerProps: {
            className: `${className}__quantity`
        },
        LabelContainerProps: {
            tag: 'label',
            className: `${className}__product-quantity-label`,
            htmlFor: `${className}__product-quantity-input`
        },
        heading: <div className={`${className}__product-quantity-label-heading`}>{resources.productQuantityHeading}</div>,
        errors: quantityError && (
            <span className='msc-alert msc-alert-noborder msc-alert-danger'>
                <span className='msi-exclamation-triangle' aria-hidden='true' />
                <span>{quantityError}</span>
            </span>
        ),
        input: (
            <Quantity
                id={`${className}__product-quantity-input`}
                max={max}
                currentCount={quantity}
                onChange={onQuantityChangeHandler(callbacks)}
                inputQuantityAriaLabel={resources.inputQuantityAriaLabel}
                telemetryContent={telemetryContent}
            />
        )
    };
}

export function getBuyboxShopSimilarButton(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    buttonType: ShopSimiliarButtonType
): IBuyboxShopSimilarLookViewProps {
    const { resources, context, typeName } = props;
    const product = props.data.product?.result;

    const className = _getClassNamePrefix(typeName);
    const navigationUrl = (shopSimiliarButtonType: ShopSimiliarButtonType) => () => {
        const searchURL = getUrlSync('search', context && context.actionContext);
        const separator = searchURL!.includes('?') ? '&' : '?';
        document.location.href = `${searchURL}${separator}productId=${product &&
            product.RecordId}&recommendation=${shopSimiliarButtonType}`;
    };
    const telemetryText =
        buttonType === ShopSimiliarButtonType.Looks ? TelemetryConstant.ShopSimliarLooks : TelemetryConstant.ShopSimliarDescription;
    const payLoad = getPayloadObject('click', telemetryContent, telemetryText);
    const attribute = getTelemetryAttributes(telemetryContent, payLoad);
    const text = buttonType === ShopSimiliarButtonType.Looks ? resources.shopSimilarLooksText : resources.shopSimilarDescriptionText;

    return {
        ContainerProps: {
            className: `${className}__shopsimilar${buttonType}`
        },
        input: (
            <Button
                title={text}
                className={`${className}__shop-similar-${buttonType}-button`}
                aria-label={text}
                onClick={navigationUrl(buttonType)}
                {...attribute}
            >
                {text}
            </Button>
        )
    };
}

/**
 * On price change function.
 * @param callbacks -Buybox callbacks.
 * @returns Update key in price.
 */
const onPriceChangeHandler = (callbacks: IBuyboxCallbacks) => (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = event.currentTarget.value;
    callbacks.updateKeyInPrice(value.length > 0 ? Number(value) : Number.parseFloat(value));
};

export function getBuyboxKeyInPrice(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState,
    callbacks: IBuyboxCallbacks
): IBuyboxKeyInPriceViewProps {
    const { config, resources } = props;

    const {
        errorState: {}
    } = state;

    const className = _getClassNamePrefix(props.typeName);

    return {
        ContainerProps: {
            className: `${className}__key_in_price`
        },
        LabelContainerProps: {
            tag: 'label',
            className: `${className}__key_in_price-label`,
            htmlFor: `${className}__key_in_price`
        },
        heading: <div className={`${className}__key_in_price-label-heading`}>{resources.buyboxKeyInPriceLabelHeading}</div>,
        input: (
            <input
                type='number'
                className={`${className}__key_in_price_custom-amount__input`}
                onChange={onPriceChangeHandler(callbacks)}
                aria-label={resources.buyboxKeyInPriceLabelHeading}
                aria-valuemin={config.minimumKeyInPrice}
                aria-valuemax={config.minimumKeyInPrice}
                aria-valuenow={state.keyInPriceAmount}
                value={state.keyInPriceAmount}
                min={config.minimumKeyInPrice}
                max={config.minimumKeyInPrice}
            />
        )
    };
}

export const BuyboxErrorBlock: React.FC<IBuyboxErrorBlockProps> = ({
    showError,
    configureErrors,
    quantityError,
    customAmountError,
    otherError,
    resources
}) => {
    let errorMessages: (string | undefined)[] = [];

    errorMessages = Object.values(configureErrors).filter(message => message !== undefined);

    if (quantityError) {
        errorMessages.push(quantityError);
    }

    if (customAmountError) {
        errorMessages.push(customAmountError);
    }

    if (otherError) {
        errorMessages.push(otherError);
    }

    return (
        <Alert isOpen={showError && errorMessages.length > 0} color='danger' assertive aria-label={resources.buyboxErrorMessageHeader}>
            <div className='msc-alert__header' aria-hidden='true'>
                <span className='msi-exclamation-triangle' />
                <span>{resources.buyboxErrorMessageHeader}</span>
            </div>
            {errorMessages.map((message, index) => {
                return (
                    <div key={index} className='msc-alert__line'>
                        {message}
                    </div>
                );
            })}
        </Alert>
    );
};

export function getQuantityLimitsMessages(
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    state: IBuyboxState
): React.ReactElement | undefined {
    const { resources } = props;

    const { min, max } = state;

    if (!_isOrderQuantityLimitsFeatureEnabled(props)) {
        return undefined;
    }

    return (
        <Node className='quantity_text_message'>
            {_renderMaxLabel(props, max, resources.maxQuantityText)}
            {_renderMinLabel(props, min, resources.minQuantityText)}
        </Node>
    );
}

// tslint:disable-next-line:max-line-length
export function getBuyboxKitProductDescription(
    props: IKitBuyboxProps<IKitBuyboxData>,
    kitProductDescription: {
        Description: string | undefined;
        Dimensions: ProductDimension[] | undefined;
        Price: number | undefined;
        productUrl: string | undefined;
    }[]
): React.ReactElement | undefined {
    const {
        data: {
            product: { result: product }
        }
    } = props;
    return (
        product &&
        kitProductDescription && (
            <div>
                <p className='ms-buybox__product-description ms-buybox__kit-product-description'>{product.Description}</p>
                <p className='ms-buybox__kit-product-description__item'>This kit includes:</p>
                <ul>
                    {kitProductDescription.map((item, idx) => {
                        return (
                            <li key={idx} className='ms-buybox__kit-product-description__item'>
                                <a href={item.productUrl}>{item.Description}</a>
                                <p>
                                    {item.Dimensions &&
                                        item.Dimensions.map((dimension, i) => {
                                            return `${dimension && dimension.DimensionValue && dimension.DimensionValue.Value} ${
                                                item.Dimensions && i < item.Dimensions.length - 1 ? ' : ' : ''
                                            }`;
                                        })}
                                </p>
                                <p>Price: {item.Price}</p>
                            </li>
                        );
                    })}
                </ul>
            </div>
        )
    );
}

export const RetailDefaultOrderQuantityLimitsFeatureName: string = 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature';

const _renderMaxLabel = (
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    max: number | undefined,
    maxQuantityText: string
): React.ReactElement | undefined => {
    const { resources, typeName } = props;
    const className = _getClassNamePrefix(typeName);
    if (max && max !== 0 && max !== Number.MAX_VALUE) {
        return (
            <p className={`${className}__minmax_label_text`}>
                <span className='sr-only'>{resources.informationIconText}</span>
                <i className='msi-InfoCircle' aria-hidden='true' />
                {maxQuantityText.replace('{max}', max.toString())}
            </p>
        );
    }
    return undefined;
};

const _renderMinLabel = (
    props: IBuyboxExtentedProps<IBuyboxCommonData>,
    min: number | undefined,
    minQuantityText: string
): JSX.Element | undefined => {
    const { resources, typeName } = props;
    const className = _getClassNamePrefix(typeName);
    if (min && min > 1) {
        return (
            <p className={`${className}__minmax_label_text`}>
                <span className='sr-only'>{resources.informationIconText}</span>
                <i className='msi-InfoCircle' aria-hidden='true' />
                {minQuantityText.replace('{min}', min.toString())}
            </p>
        );
    }
    return undefined;
};

const _isOrderQuantityLimitsFeatureEnabled = (props: IBuyboxExtentedProps<IBuyboxCommonData>): boolean | undefined => {
    const isFeatureEnabledInHq = props.data.featureState.result?.find(
        featureState => featureState.Name === RetailDefaultOrderQuantityLimitsFeatureName
    )?.IsEnabled;
    if (!isFeatureEnabledInHq) {
        return false;
    }
    const defaultOrderQuantityLimitsFeatureConfig = props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
    if (defaultOrderQuantityLimitsFeatureConfig === 'none') {
        return false;
    }

    if (defaultOrderQuantityLimitsFeatureConfig === 'all') {
        return true;
    }

    const customerInfo = props.data.customerInformation.result;
    return (
        customerInfo &&
        ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
            (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b))
    );
};
