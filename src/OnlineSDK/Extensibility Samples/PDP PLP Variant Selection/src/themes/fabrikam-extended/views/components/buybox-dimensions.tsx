/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

import { IBuyboxData, IBuyboxViewProps } from '@msdyn365-commerce-modules/buybox';
import { IBuyboxResources } from '@msdyn365-commerce-modules/buybox/dist/types/index';
import MsDyn365, { CacheType, IImageData } from '@msdyn365-commerce/core';
import {
    getEstimatedAvailabilityAsync,
    getVariantsByDimensionValuesAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/ProductsDataActions.g';
import {
    AttributeValue,
    ProductDimension,
    ProductDimensionValue,
    ProductWarehouseInventoryAvailability,
    SimpleProduct
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { observable, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';
import {
    AttributesForSelectedVariantInput,
    getAttributesForSelectedVariantAction
} from '../../../../dataActions/get-attributes-for-selected-variant';
import { IBuyboxProps as IBuyboxExtentionProps } from '../../definition-extensions/buybox.ext.props.autogenerated';
import { getValidProductImages } from '../../utilities/get-valid-product-images';
import { Dropdown } from './dropdown';
import { IDropdownItemProps, IDropdownOnSelectionChangeNotification } from './dropdown.props';

export interface IBuyboxDimensionsState {
    reRender: boolean;
    colorDimensionSelected: ProductDimension;
    sizeDimensionSelected: ProductDimension;
    isColorSelected: boolean;
    isSizeSelected: boolean;
}

/**
 *
 * BuyboxDimensions component
 * @extends {React.PureComponent<IBuyboxViewProps, IBuyboxProps & IBuyboxExtentionProps<IBuyboxData> & IBuyboxDimensionsState>}
 */
@observer
export class BuyboxDimensions extends React.PureComponent<IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData>, IBuyboxDimensionsState> {
    private sampleProduct: SimpleProduct | undefined;
    private colorSwatchHex: string;
    private colorSwatchId: string;
    @observable private colorSwatchDimensionId: number;
    @observable private sizeSwatchDimensionId: number;
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    private varientsInventoriesJson: any;
    private imageSwatchId: string;
    private imageSwatchUrl: string;
    private colorDimensionTypeValue: number;
    private sizeDimensionTypeValue: number;
    private selectedProductId: number;
    private masterProductId: string;
    private isColorChange: boolean;
    private dimid: string = '';
    private dimensionValue: ProductDimensionValue;
    private recentColorSwatchDimensionId: number;
    private latestColorCallbackId: number;
    private latestSizeCallbackId: number;
    constructor(props: IBuyboxViewProps & IBuyboxExtentionProps<IBuyboxData> & IBuyboxDimensionsState) {
        super(props);
        this.sampleProduct = { RecordId: 0, ProductTypeValue: 0, BasePrice: 0, Price: 0, AdjustedPrice: 0 };
        this.colorSwatchHex = ';';
        this.colorSwatchId = '';
        this.colorSwatchDimensionId = 0;
        this.sizeSwatchDimensionId = 0;
        this.varientsInventoriesJson = [];
        this.setState({
            reRender: false,
            colorDimensionSelected: { DimensionTypeValue: 0 },
            sizeDimensionSelected: { DimensionTypeValue: 0 },
            isColorSelected: false,
            isSizeSelected: false
        });
        this.imageSwatchId = '';
        this.imageSwatchUrl = '';
        this.colorDimensionTypeValue = 1;
        this.sizeDimensionTypeValue = 3;
        this.selectedProductId = 0;
        this.masterProductId = '';
        this.isColorChange = false;
        if (MsDyn365.isBrowser) {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('dimid')) {
                this.dimid = urlParams.get('dimid') || '';
            } else {
                this.dimid = '';
            }
        }
        this.dimensionValue = { RecordId: 0 };
        this.recentColorSwatchDimensionId = 0;
        this.latestColorCallbackId = 0;
        this.latestSizeCallbackId = 0;
    }

    // tslint:disable: typedef cyclomatic-complexity max-func-body-length
    // eslint-disable-next-line complexity
    public async componentDidMount() {
        const {
            config,
            context,
            data: {
                productDimensions: { result: productDimensions }
            },
            state
        } = this.props;

        this.sampleProduct = (await state.selectedProduct) || undefined;

        const input: AttributesForSelectedVariantInput = {
            productId: this.sampleProduct?.RecordId || 0,
            channelId: context.request.apiSettings.channelId,
            selectedProduct: this.sampleProduct,
            catalogId: 0,
            getCacheKey: () => `AttributesForSelectedVariant`,
            getCacheObjectType: () => 'ProductAttributeValue',
            dataCacheType: (): CacheType => 'none'
        };

        const attributes: AttributeValue[] = await getAttributesForSelectedVariantAction(input, context.actionContext);

        const colorswatch: AttributeValue[] = attributes && attributes.filter(x => x.Name?.toLocaleLowerCase() === 'colorhexmapping');
        const colorImageMapping: AttributeValue[] =
            attributes && attributes.filter(x => x.Name?.toLocaleLowerCase() === 'colorimagevariantmapping');
        const imagesData =
            colorImageMapping &&
            colorImageMapping.length > 0 &&
            colorImageMapping[0] &&
            colorImageMapping[0].TextValue &&
            this._getParsedJson(colorImageMapping[0].TextValue);
        const colorData =
            colorswatch &&
            colorswatch.length > 0 &&
            colorswatch[0] &&
            colorswatch[0].TextValue &&
            this._getParsedJson(colorswatch[0].TextValue);
        this.colorSwatchHex = '';
        const baseImageUrl = context.request.apiSettings.baseImageUrl;
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        let colorSwatchMappingObj: any[] = [];
        if (colorData && colorData.length > 0) {
            // tslint:disable-next-line:no-any
            colorSwatchMappingObj = colorData.map((item: any, index: number) => {
                return (
                    // tslint:disable-next-line:ban-comma-operator
                    // eslint-disable-next-line no-sequences
                    Object.keys(item).reduce((c, k) => ((c[k.toLowerCase()] = item[k]), c), {})
                );
            });
        }

        /* eslint-disable  @typescript-eslint/no-explicit-any */
        let colorImgMappingObj: any[] = [];
        if (imagesData && imagesData.length > 0) {
            // tslint:disable-next-line:no-any
            colorImgMappingObj = imagesData.map((item: any, index: number) => {
                return (
                    // tslint:disable-next-line:ban-comma-operator
                    // eslint-disable-next-line no-sequences
                    Object.keys(item).reduce((c, k) => ((c[k.toLowerCase()] = item[k]), c), {})
                );
            });
        }

        // tslint:disable-next-line: no-any
        colorSwatchMappingObj &&
            colorSwatchMappingObj.forEach((object: any) => {
                this.colorSwatchHex = `${this.colorSwatchHex}${String(object.hex)};`;
                this.colorSwatchId = `${this.colorSwatchId}${String(object.id)};`;
            });
        // tslint:disable-next-line: no-any
        colorImgMappingObj &&
            colorImgMappingObj.forEach((object: any) => {
                this.imageSwatchId = `${this.imageSwatchId}${String(object.id)};`;
                this.imageSwatchUrl = `${this.imageSwatchUrl}${baseImageUrl}Products/${String(object.url).replace(/ /g, '')};`;
            });

        if (this.colorSwatchHex.length > 0) {
            this.colorSwatchHex = this.colorSwatchHex.slice(0, -1);
        }

        if (this.colorSwatchId.length > 0) {
            this.colorSwatchId = this.colorSwatchId.slice(0, -1);
        }

        if (config.enableVariantsOOSInventoryCheck) {
            await this._getVarientsInventory().then(result => {
                this.setState({ reRender: true });
            });
        }

        if (this.imageSwatchId.length > 0) {
            this.imageSwatchId = this.imageSwatchId.slice(0, -1);
        }

        if (this.imageSwatchUrl.length > 0) {
            this.imageSwatchUrl = this.imageSwatchUrl.slice(0, -1);
        }

        if (this.props.data.product.result && context.actionContext.requestContext.urlTokens.recordId) {
            this.masterProductId = context.actionContext.requestContext.urlTokens.recordId || '';
        }

        productDimensions &&
            productDimensions.map(async dimension => {
                if (dimension.DimensionValues && dimension.DimensionValues.length === 1 && dimension.DimensionTypeValue === 1) {
                    await this.props.callbacks.dimensionSelectedAsync(
                        dimension.DimensionTypeValue,
                        dimension.DimensionValues[0].RecordId.toString()
                    );
                }
            });

        reaction(
            () => (this.props.data.product.result ? this.props.data.product.result.RecordId : null),
            async () => {
                const { isColorSelected, isSizeSelected } = this.state;
                // tslint:disable-next-line: no-any
                const varient = this.varientsInventoriesJson.filter(
                    (product: any) => product.colorId === this.colorSwatchDimensionId && product.sizeId === this.sizeSwatchDimensionId
                );
                const varientProductId = varient && varient.length > 0 && varient[0].productId;
                const productId = this.props.data.product.result && this.props.data.product.result.RecordId;
                if (
                    (this.isColorChange ||
                        this.recentColorSwatchDimensionId !== this.colorSwatchDimensionId ||
                        varientProductId !== productId) &&
                    isColorSelected &&
                    isSizeSelected &&
                    this.props.data.product.result
                ) {
                    await this.addExtensions(this.props.data.product.result);
                    await this.props.callbacks.dimensionSelectedAsync(this.colorDimensionTypeValue, String(this.colorSwatchDimensionId));
                    await this.props.callbacks.dimensionSelectedAsync(this.sizeDimensionTypeValue, String(this.sizeSwatchDimensionId));
                }
                if (this.selectedProductId === 0) {
                    await this._updateProduct();
                }
            }
        );

        reaction(
            () => (this.colorSwatchDimensionId ? this.colorSwatchDimensionId : 0),
            async () => {
                if (this.colorSwatchDimensionId !== this.latestColorCallbackId) {
                    this.colorSwatchDimensionId &&
                        (await this.props.callbacks.dimensionSelectedAsync(
                            this.colorDimensionTypeValue,
                            String(this.colorSwatchDimensionId)
                        ));
                }
                if (this.sizeSwatchDimensionId !== this.latestSizeCallbackId) {
                    this.sizeSwatchDimensionId &&
                        (await this.props.callbacks.dimensionSelectedAsync(
                            this.sizeDimensionTypeValue,
                            String(this.sizeSwatchDimensionId)
                        ));
                }
            }
        );

        reaction(
            () => (this.sizeSwatchDimensionId ? this.sizeSwatchDimensionId : 0),
            async () => {
                if (this.sizeSwatchDimensionId !== this.latestSizeCallbackId) {
                    this.sizeSwatchDimensionId &&
                        (await this.props.callbacks.dimensionSelectedAsync(
                            this.sizeDimensionTypeValue,
                            String(this.sizeSwatchDimensionId)
                        ));
                }
                if (this.colorSwatchDimensionId !== this.latestColorCallbackId) {
                    this.colorSwatchDimensionId &&
                        (await this.props.callbacks.dimensionSelectedAsync(
                            this.colorDimensionTypeValue,
                            String(this.colorSwatchDimensionId)
                        ));
                }
            }
        );

        if (config.selectColorDimensionOnloadFlag) {
            if (!this.isColorChange && this.dimid.length > 0 && this.dimensionValue.RecordId !== 0) {
                this.selectColor(this.colorDimensionTypeValue, this.dimensionValue);
            } else {
                const colorDimensions =
                    (productDimensions &&
                        productDimensions.filter(dimension => dimension.DimensionTypeValue === this.colorDimensionTypeValue)) ||
                    [];
                const colorDimensionValues = (colorDimensions.length > 0 && colorDimensions[0].DimensionValues) || [];
                const firstColorDimensionValue = colorDimensionValues.length > 0 && colorDimensionValues[0];
                if (firstColorDimensionValue) {
                    this.selectColor(this.colorDimensionTypeValue, firstColorDimensionValue);
                }
            }
        }
    }

    // tslint:disable-next-line: max-func-body-length
    public render(): JSX.Element {
        return (
            <div className='dimension-swatch'>
                {this.renderColorSwatch()}
                {this.renderSizeSwatches()}
                {this.renderDropdowns()}
            </div>
        );
    }

    // tslint:disable-next-line: max-func-body-length
    public renderColorSwatch(): JSX.Element {
        const {
            config,
            data: {
                productDimensions: { result: productDimensions }
            },
            resources,
            callbacks
        } = this.props;
        let bgColor: React.CSSProperties = {};
        const colorSwatchIdArray = this.colorSwatchId.split(';');
        const colorSwatchHexArray = this.colorSwatchHex.split(';');
        const dimensionName = callbacks.getDropdownName(this.colorDimensionTypeValue, resources);
        const colorSelected =
            (this.state &&
                this.state.colorDimensionSelected &&
                this.state.colorDimensionSelected.DimensionValue &&
                this.state.colorDimensionSelected.DimensionValue.Value) ||
            '';
        return (
            <div className='dimension-swatch'>
                <div className={`custom-color-wrap`}>
                    <div className='swatch-heading'>
                        {dimensionName}
                        {' : '}
                        <span>{colorSelected}</span>
                    </div>
                    {productDimensions
                        ? productDimensions
                              .filter(filter => filter.DimensionTypeValue === 1)
                              .map((dimension, i) => {
                                  return (
                                      <ul className={`custom-swatches color-swatch`} key={i}>
                                          {dimension.DimensionValues
                                              ? // tslint:disable-next-line: cyclomatic-complexity
                                                dimension.DimensionValues.map((dimensionValue, index) => {
                                                    let colorMatchFound = false;
                                                    if (this.colorSwatchHex.length) {
                                                        colorSwatchIdArray &&
                                                            colorSwatchIdArray.map((id, swatchIndex) => {
                                                                if (
                                                                    dimensionValue.DimensionId?.toLocaleLowerCase() ===
                                                                    id.toLocaleLowerCase()
                                                                ) {
                                                                    bgColor = {
                                                                        backgroundColor:
                                                                            (colorSwatchHexArray && colorSwatchHexArray[swatchIndex]) || ''
                                                                    };
                                                                    colorMatchFound = true;
                                                                }
                                                            });
                                                    }
                                                    if (!colorMatchFound) {
                                                        bgColor = {
                                                            backgroundColor:
                                                                (this.colorSwatchHex.length > 1 && config.defaultColorHex) || 'transparent'
                                                        };
                                                    }
                                                    let inventoryClass = '';
                                                    if (config.enableVariantsOOSInventoryCheck && this.varientsInventoriesJson.length) {
                                                        // tslint:disable-next-line: no-any
                                                        const colorInventory = this.varientsInventoriesJson.filter(
                                                            (inventory: any) =>
                                                                inventory.colorId === dimensionValue.RecordId &&
                                                                (inventory.totalAvailable || 0) > 0
                                                        );
                                                        inventoryClass = colorInventory && colorInventory.length > 0 ? '' : 'out_of_stock';
                                                    }

                                                    if (config.selectColorDimensionOnloadFlag) {
                                                        if (dimensionValue.DimensionId === this.dimid) {
                                                            this.dimensionValue = dimensionValue;
                                                        }
                                                    }

                                                    return (
                                                        <li
                                                            key={index}
                                                            className={
                                                                colorSelected === dimensionValue.Value
                                                                    ? `selected ${inventoryClass} color_${dimensionValue.Value || ''}`
                                                                    : `color ${inventoryClass}`
                                                            }
                                                            onClick={this.generateOnClick(dimension.DimensionTypeValue, dimensionValue)}
                                                            role='button'
                                                        >
                                                            <button style={bgColor || {}}>
                                                                <span className='tooltip'>{dimensionValue.Value}</span>
                                                            </button>
                                                        </li>
                                                    );
                                                })
                                              : false}
                                      </ul>
                                  );
                              })
                        : false}
                </div>
            </div>
        );
    }

    // tslint:disable-next-line: max-func-body-length
    public renderSizeSwatches(): JSX.Element {
        const {
            config,
            data: {
                productDimensions: { result: productDimensions }
            },
            resources,
            callbacks
        } = this.props;
        const dimensionName = callbacks.getDropdownName(this.sizeDimensionTypeValue, resources).toLowerCase();
        const sizeSelected =
            (this.state &&
                this.state.sizeDimensionSelected &&
                this.state.sizeDimensionSelected.DimensionValue &&
                this.state.sizeDimensionSelected.DimensionValue.Value) ||
            '';
        return (
            <div className='dimension-swatch'>
                <div className={`custom-size-wrap`}>
                    <div className='swatch-heading'>
                        {dimensionName}
                        {' : '}
                        <span>{sizeSelected}</span>
                    </div>
                    {productDimensions
                        ? productDimensions
                              .filter(filter => filter.DimensionTypeValue === 3)
                              .map((dimension, i) => {
                                  return (
                                      <ul className={`custom-swatches size-swatch`} key={i}>
                                          {dimension.DimensionValues
                                              ? dimension.DimensionValues.map((dimensionValue, index) => {
                                                    let inventoryClass = '';
                                                    if (config.enableVariantsOOSInventoryCheck && this.varientsInventoriesJson.length) {
                                                        // tslint:disable-next-line: no-any
                                                        const sizeInventory = this.varientsInventoriesJson.filter(
                                                            (inventory: any) =>
                                                                inventory.sizeId === dimensionValue.RecordId &&
                                                                (inventory.totalAvailable || 0) > 0
                                                        );
                                                        inventoryClass = sizeInventory && sizeInventory.length > 0 ? '' : 'out_of_stock';
                                                    }
                                                    if (
                                                        config.enableVariantsOOSInventoryCheck &&
                                                        this.colorSwatchDimensionId &&
                                                        this.varientsInventoriesJson.length
                                                    ) {
                                                        // tslint:disable-next-line: no-any
                                                        const sizeInventory = this.varientsInventoriesJson.filter(
                                                            (inventory: any) =>
                                                                inventory.colorId === this.colorSwatchDimensionId &&
                                                                inventory.sizeId === dimensionValue.RecordId
                                                        );
                                                        inventoryClass =
                                                            sizeInventory && sizeInventory.length > 0 && sizeInventory[0].totalAvailable > 0
                                                                ? ''
                                                                : 'out_of_stock';
                                                    }

                                                    return (
                                                        <li
                                                            key={index}
                                                            className={
                                                                sizeSelected === dimensionValue.Value
                                                                    ? `selected ${inventoryClass} size_${dimensionValue.Value || ''}`
                                                                    : `size ${inventoryClass}`
                                                            }
                                                            onClick={this.generateOnClick(dimension.DimensionTypeValue, dimensionValue)}
                                                            role='button'
                                                        >
                                                            <button>{dimensionValue.Value}</button>
                                                        </li>
                                                    );
                                                })
                                              : false}
                                      </ul>
                                  );
                              })
                        : false}
                </div>
            </div>
        );
    }

    private renderDropdowns = (): JSX.Element => {
        const {
            data: {
                productDimensions: { result: productDimensions }
            },
            resources,
            callbacks
        } = this.props;

        const sortedProductDimensions = productDimensions?.sort((a, b) => (a.DimensionTypeValue > b.DimensionTypeValue ? 1 : -1));

        return (
            <div>
                {sortedProductDimensions
                    ? // tslint:disable-next-line: max-func-body-length
                      sortedProductDimensions?.map((dimension, i) => {
                          const swatchName = this._getDropdownName(dimension.DimensionTypeValue, resources).toLowerCase();
                          const isColorSwatch = dimension.DimensionTypeValue === 1;
                          const isSizeSwatch = dimension.DimensionTypeValue === 3;

                          if (!isSizeSwatch && !isColorSwatch) {
                              const dropdownName = callbacks.getDropdownName(dimension.DimensionTypeValue, resources);
                              const dropdownId = dimension.DimensionTypeValue.toString();
                              let dropdownToggleName = resources.selectDimensionFormatString.replace(
                                  '{0}',
                                  dropdownName.toLocaleLowerCase()
                              );
                              if (dropdownName.toLocaleLowerCase() === 'style') {
                                  dropdownToggleName = 'Choose single, pack, or case';
                              }

                              const dropdownList: IDropdownItemProps[] = dimension.DimensionValues
                                  ? dimension.DimensionValues.map<IDropdownItemProps>(dimensionValue => {
                                        return {
                                            value: dimensionValue.Value || '',
                                            id: dimensionValue.RecordId.toString()
                                        };
                                    })
                                  : [];

                              return (
                                  <div className={'ms-buybox__dropdown'} key={i}>
                                      <label className='ms_buybox__dropdown-quantity-label'>{swatchName}</label>
                                      <div className='ms-buybox__select-wrapper'>
                                          <Dropdown
                                              dropdownId={dropdownId}
                                              dropdownName={dropdownName}
                                              dropdownToggleName={dropdownToggleName}
                                              dropdownList={dropdownList}
                                              onChange={this.onChanged}
                                          />
                                      </div>
                                  </div>
                              );
                          } else {
                              return null;
                          }
                      })
                    : false}
            </div>
        );
    };

    private generateOnClick = (dimensionTypeValue: number, dimensionValue: ProductDimensionValue) => async (
        event: React.MouseEvent<HTMLLIElement, MouseEvent>
    ): Promise<void> => {
        this.selectedProductId = 0;
        if (dimensionTypeValue === this.colorDimensionTypeValue) {
            this.colorSwatchDimensionId = dimensionValue.RecordId;
            this.isColorChange = true;
            this.setState({
                isColorSelected: true,
                colorDimensionSelected: { DimensionTypeValue: dimensionTypeValue, DimensionValue: dimensionValue }
            });
        } else if (dimensionTypeValue === this.sizeDimensionTypeValue) {
            this.sizeSwatchDimensionId = dimensionValue.RecordId;
            this.isColorChange = false;
            this.setState({
                isSizeSelected: true,
                sizeDimensionSelected: { DimensionTypeValue: dimensionTypeValue, DimensionValue: dimensionValue }
            });
        }
        if (this.props.data.product.result && this.sizeSwatchDimensionId === 0) {
            await this.addExtensions(this.props.data.product.result);
        }

        if (dimensionValue.RecordId) {
            await this.props.callbacks.dimensionSelectedAsync(dimensionTypeValue, dimensionValue.RecordId.toString());
            if (dimensionTypeValue === this.colorDimensionTypeValue) {
                this.latestColorCallbackId = dimensionValue.RecordId;
            } else if (dimensionTypeValue === this.sizeDimensionTypeValue) {
                this.latestSizeCallbackId = dimensionValue.RecordId;
            }
        }
    };

    private selectColor = (dimensionTypeValue: number, dimensionValue: ProductDimensionValue) => {
        this.colorSwatchDimensionId = dimensionValue.RecordId;
        this.isColorChange = true;
        this.setState({
            isColorSelected: true,
            colorDimensionSelected: { DimensionTypeValue: dimensionTypeValue, DimensionValue: dimensionValue }
        });
        // tslint:disable-next-line: no-floating-promises
        this.updateSelectedColor(dimensionTypeValue, dimensionValue);
    };

    private updateSelectedColor = async (dimensionTypeValue: number, dimensionValue: ProductDimensionValue): Promise<void> => {
        if (this.props.data.product.result && this.sizeSwatchDimensionId === 0) {
            this.props.data.product.result && (await this.addExtensions(this.props.data.product.result));
            await this.props.callbacks.dimensionSelectedAsync(dimensionTypeValue, dimensionValue.RecordId.toString());
        }
    };

    private addExtensions = async (product: SimpleProduct): Promise<void> => {
        const imageData = this.sizeSwatchDimensionId === 0 ? await this.getImages() : await this.getImages(product.RecordId);
        let src = '';
        imageData.forEach(data => {
            src = `${src}${data.src};`;
        });
        if (src.length > 0) {
            src = src.slice(0, -1);
        }
        this.masterProductId.length > 0 && this._addProductExtension(product, 'MasterProductId', this.masterProductId);
        this.masterProductId.length > 0 &&
            this._addProductExtension(product, 'SelectedColorSwatch', this.state.colorDimensionSelected.DimensionValue?.Value || '');
        src.length > 0 && this._addProductExtension(product, 'ColorSwatchProductImageUrl', src);
    };

    private getImages = async (productId?: number): Promise<IImageData[]> => {
        const { context } = this.props;
        if (productId === undefined) {
            // tslint:disable-next-line: no-any
            let colorInventory = this.varientsInventoriesJson.filter(
                (inventory: any) => inventory.colorId === this.colorSwatchDimensionId && (inventory.totalAvailable || 0) > 0
            );
            if (colorInventory.length === 0) {
                // tslint:disable-next-line: no-any
                colorInventory = this.varientsInventoriesJson.filter((inventory: any) => inventory.colorId === this.colorSwatchDimensionId);
            }
            const recordId = (colorInventory && colorInventory.length > 0 && Number(colorInventory[0].productId)) || 0;
            productId = recordId;
        }
        // tslint:disable-next-line: no-return-await
        const images = await getValidProductImages(productId, context.request.apiSettings.channelId, context.actionContext);
        if (images && images.length > 0) {
            return images;
        }
        return [];
    };

    private onChanged = async (notification: IDropdownOnSelectionChangeNotification) =>
        this._onChanged(notification, this.props.callbacks.dimensionSelectedAsync);

    private _onChanged = async (
        notification: IDropdownOnSelectionChangeNotification,
        dimensionChanged: (newValue: number, selectedDimensionValue: string) => Promise<void>
    ): Promise<void> => {
        await dimensionChanged(+notification.dropdownId, notification.selectId);
    };

    private _getDropdownName = (dimensionType: number, resources: IBuyboxResources): string => {
        switch (dimensionType) {
            case 1: // ProductDimensionType.Color
                return resources.productDimensionTypeColor;
            case 2: // ProductDimensionType.Configuration
                return resources.productDimensionTypeConfiguration;
            case 3: // ProductDimensionType.Size
                return resources.productDimensionTypeSize;
            case 4: // ProductDimensionType.Style
                return resources.productDimensionTypeStyle;
            default:
                return '';
        }
    };

    private _getVarientsInventory = async (): Promise<void> => {
        const { context } = this.props;
        let recordIds = '';
        const variants: SimpleProduct[] = await getVariantsByDimensionValuesAsync(
            { callerContext: context.actionContext, queryResultSettings: {} },
            Number(context.actionContext.requestContext.urlTokens.recordId),
            context.request.apiSettings.channelId,
            []
        );
        let variantsJsonString: string = '[';
        variants.forEach(varient => {
            const colorDimension: ProductDimension[] =
                (varient.Dimensions && varient.Dimensions.filter(x => x.DimensionTypeValue === 1)) || [];
            const sizeDimension: ProductDimension[] =
                (varient.Dimensions && varient.Dimensions.filter(x => x.DimensionTypeValue === 3)) || [];
            const colorRecordId =
                (colorDimension &&
                    colorDimension.length > 0 &&
                    colorDimension[0].DimensionValue &&
                    colorDimension[0].DimensionValue.RecordId.toString()) ||
                '';
            const colorValue =
                (colorDimension &&
                    colorDimension.length > 0 &&
                    colorDimension[0].DimensionValue &&
                    colorDimension[0].DimensionValue.Value &&
                    colorDimension[0].DimensionValue.Value.toString()) ||
                '';
            const sizeRecordId =
                (sizeDimension &&
                    sizeDimension.length > 0 &&
                    sizeDimension[0].DimensionValue &&
                    sizeDimension[0].DimensionValue.RecordId.toString()) ||
                '';
            const sizeValue =
                (sizeDimension &&
                    sizeDimension.length > 0 &&
                    sizeDimension[0].DimensionValue &&
                    sizeDimension[0].DimensionValue.Value &&
                    sizeDimension[0].DimensionValue.Value.toString()) ||
                '';
            const recordId = varient.RecordId.toString();
            variantsJsonString = `${variantsJsonString}{"productId": ${recordId}, "color": "${colorValue}", "size": "${sizeValue}", "colorId": ${colorRecordId}, "sizeId": ${sizeRecordId}},`;
            recordIds = `${recordIds}${recordId},`;
        });

        if (variantsJsonString.length > 1) {
            variantsJsonString = variantsJsonString.slice(0, -1);
        }

        variantsJsonString = `${variantsJsonString}]`;
        const variantsJson = this._getParsedJson(variantsJsonString);

        if (recordIds.length > 0) {
            recordIds = recordIds.slice(0, -1);
        }

        const ids = recordIds.split(',').map(x => +x);

        const variantsAvailabilites = await getEstimatedAvailabilityAsync(
            { callerContext: context.actionContext },
            { ProductIds: ids, DefaultWarehouseOnly: true }
        );

        let inventoriesJsonString: string = '[';
        const inventories: ProductWarehouseInventoryAvailability[] = variantsAvailabilites.ProductWarehouseInventoryAvailabilities || [];
        inventories.forEach(inventory => {
            if (context.actionContext.requestContext.app.config.inventoryLevel) {
                switch (context.actionContext.requestContext.app.config.inventoryLevel) {
                    case 'physicalAvailable':
                        // Inventory level is enabled with Physical inventory
                        inventoriesJsonString = `${inventoriesJsonString}{"productId": ${inventory.ProductId}, "totalAvailable": ${inventory.PhysicalAvailable}},`;
                        break;
                    case 'totalAvailable':
                        // Inventory level is enabled with Total available inventory
                        inventoriesJsonString = `${inventoriesJsonString}{"productId": ${inventory.ProductId}, "totalAvailable": ${inventory.TotalAvailable}},`;
                        break;
                    default:
                        // when inventory level is inventoryThreshold or not defined
                        inventoriesJsonString = `${inventoriesJsonString}{"productId": ${
                            inventory.ProductId
                        }, "totalAvailable": ${inventory.TotalAvailable &&
                            inventory.TotalAvailable - context.actionContext.requestContext.app.config.outOfStockThreshold}},`;
                }
            }
        });

        if (inventoriesJsonString.length > 1) {
            inventoriesJsonString = inventoriesJsonString.slice(0, -1);
        }
        inventoriesJsonString = `${inventoriesJsonString}]`;

        const inventoriesJson = this._getParsedJson(inventoriesJsonString);

        if (variantsJson && variantsJson.length) {
            for (let i = 0; i < variantsJson.length; i++) {
                this.varientsInventoriesJson.push({
                    ...variantsJson[i],
                    // tslint:disable-next-line:no-any
                    ...inventoriesJson.find((item: any) => item.productId === variantsJson[i].productId)
                });
            }
        }
    };

    private _addProductExtension = (
        simpleProduct: SimpleProduct | undefined,
        extensionPropertyKey: string,
        extensionPropertyValue: string
    ): void => {
        if (this.props.config.renderColorSwatchImages && simpleProduct) {
            simpleProduct.ExtensionProperties = simpleProduct.ExtensionProperties || [];
            // tslint:disable-next-line: no-any
            const property = simpleProduct.ExtensionProperties.find((extension: any) => extension.Key === extensionPropertyKey);

            if (property) {
                property.Value = { StringValue: extensionPropertyValue };
            } else {
                simpleProduct.ExtensionProperties.push({
                    Key: extensionPropertyKey,
                    Value: {
                        StringValue: extensionPropertyValue
                    }
                });
            }

            this.recentColorSwatchDimensionId = this.colorSwatchDimensionId;
        }
    };

    private _updateProduct = async (): Promise<void> => {
        const { colorDimensionSelected, sizeDimensionSelected } = this.state;
        const colorDimension: ProductDimension[] =
            this.props.data.product.result?.Dimensions?.filter(d => d.DimensionTypeValue === this.colorDimensionTypeValue) || [];
        const color = (colorDimension && colorDimension.length > 0 && colorDimension[0] && colorDimension[0].DimensionValue?.Value) || '';
        const sizeDimension: ProductDimension[] =
            this.props.data.product.result?.Dimensions?.filter(d => d.DimensionTypeValue === this.sizeDimensionTypeValue) || [];
        const size = (sizeDimension && sizeDimension.length > 0 && sizeDimension[0] && sizeDimension[0].DimensionValue?.Value) || '';
        if (color && colorDimensionSelected && colorDimensionSelected.DimensionValue?.Value !== color) {
            if (this.selectedProductId === 0) {
                await this.props.callbacks.dimensionSelectedAsync(
                    this.colorDimensionTypeValue,
                    colorDimensionSelected.DimensionValue!.RecordId.toString()
                );
            }
        }
        if (size && sizeDimensionSelected && sizeDimensionSelected.DimensionValue?.Value !== size) {
            if (this.selectedProductId === 0) {
                await this.props.callbacks.dimensionSelectedAsync(
                    this.sizeDimensionTypeValue,
                    sizeDimensionSelected.DimensionValue!.RecordId.toString()
                );
            }
        }
        if (
            color &&
            colorDimensionSelected &&
            colorDimensionSelected.DimensionValue?.Value === color &&
            size &&
            sizeDimensionSelected &&
            sizeDimensionSelected.DimensionValue?.Value === size
        ) {
            this.selectedProductId = this.props.data.product.result?.RecordId || 0;
        }
    };

    // tslint:disable-next-line: no-any
    private _getParsedJson = (text: string): any => {
        try {
            return JSON.parse(text);
        } catch (error) {
            this.props.context.telemetry.warning('Unable to parse text');
            this.props.context.telemetry.error(error);
            return '';
        }
    };
}

export default BuyboxDimensions;
