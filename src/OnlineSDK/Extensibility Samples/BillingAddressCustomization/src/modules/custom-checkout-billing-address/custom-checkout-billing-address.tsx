/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { IGiftCardExtend } from '@msdyn365-commerce/global-state';
import { Address, AddressPurpose, CountryRegionInfo, StateProvinceInfo } from '@msdyn365-commerce/retail-proxy';
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { getTelemetryObject, IModuleProps, ITelemetryContent } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { action, computed, observable, reaction, set } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { AutoSuggest } from '../../common/address-autosuggest';
import { IAutoSuggestOptions } from '../../common/address-autosuggest.data';
import { AddressCommon } from '../../common/address-common';
import { AddressSelect, IAddressSelectProps } from '../../common/components/address-select';
import { AddressFormat } from '../../common/address-format';
import { AddressItemType } from '../../common/address-format.data';
import { AddressMetaData } from '../../common/address-meta-data';
import { AddressOperation, AddressType, IAddressResource, IAddressResponse } from '../../common/address-module.data';
import { AddressAddUpdate, IAddressAddUpdateProps } from '../../common/components/address-add';
import { AddressBillingCheckbox } from '../../common/components/address-billing-checkbox';
import { AddressBillingHeading } from '../../common/components/address-billing-heading';
import { AddressShow, IAddressShowProps } from '../../common/components/address-show';
import { ICustomCheckoutBillingAddressData } from './custom-checkout-billing-address.data';
import { ICustomCheckoutBillingAddressProps } from './custom-checkout-billing-address.props.autogenerated';

/**
 * Props interface.
 */
export interface IProps extends ICustomCheckoutBillingAddressProps<ICustomCheckoutBillingAddressData>, IModuleStateProps {}

/**
 * Checkout billing address view state interface.
 */
export interface ICheckoutBillingAddressViewState {
    isShowAddress: boolean;
    isShowAddOrUpdateAddress: boolean;
    isShowAddresList: boolean;
    isShowSameAsShippingCheckbox: boolean;
}

/**
 * Checkout billing address view props interface.
 */
export interface ICheckoutBillingAddressViewProps extends IProps {
    className: string;
    currentOperation: AddressOperation;
    selectedAddress?: Address;
    addUpdateAddress: Address;
    addressListSelectedAddress: Address;
    countryRegionId: string;
    customerAddresses: Address[];
    showAddressSelect: IAddressSelectProps;
    stateProvinceInfo?: StateProvinceInfo[];
    validationError: object;
    addressActionResponse?: IAddressResponse;
    viewState: ICheckoutBillingAddressViewState;
    CheckoutBillingAddress: IModuleProps;
    sameAsShippingCheckbox: React.ReactNode;
    heading: React.ReactNode;
    showAddress: IAddressShowProps;
    showAddOrUpdateAddress: IAddressAddUpdateProps;
    isUpdating: boolean;
    hasError: boolean;
}

/**
 *
 * CheckoutBillingAddress component.
 * @extends {React.PureComponent<ICustomCheckoutBillingAddressProps<ICustomCheckoutBillingAddressData>>}
 */
// @ts-expect-error
@withModuleState
@observer
class CheckoutBillingAddress extends React.Component<IProps> {
    @observable private currentOperation: AddressOperation;

    @observable private isBillingAddressSameAsShipping: boolean;

    @observable private selectedAddress?: Address;

    @observable private addUpdateAddress: Address;

    @observable private countryRegionId: string = 'USA';

    @observable private stateProvinceInfo?: StateProvinceInfo[];

    @observable private validationError: object;

    @observable private customerAddresses: Address[];

    @observable private addressListSelectedAddress: Address = {};

    @observable private addressActionResponse?: IAddressResponse;

    @observable private isUpdating?: boolean;

    @observable private hasError?: boolean;

    private readonly addressCommon: AddressCommon;

    private addressFormat: AddressFormat;

    private isCheckoutBillingAddress: boolean;

    private countryRegions: CountryRegionInfo[] = [];

    private addressPurposes: AddressPurpose[] = [];

    private readonly resources: IAddressResource;

    private defaultAddressType: number = 6; // Default to Home

    // private addRenderRef: React.RefObject<AddressAdd>;
    private readonly telemetryContent?: ITelemetryContent;

    private autoSuggest?: AutoSuggest;

    public constructor(props: IProps) {
        super(props);
        const { context, data, resources, telemetry } = this.props;

        this.addUpdateAddress = {};
        this.validationError = {};
        this.isBillingAddressSameAsShipping = false;
        this.resources = resources;
        this.currentOperation = AddressOperation.List;
        this.customerAddresses = data.address.result?.filter(address => address.AddressTypeValue === 1) || [];
        this.addressPurposes = data.addressPurposes.result || [];
        this.countryRegions = data.countryRegions.result || [];
        this.stateProvinceInfo = data.countryStates.result || [];
        this.addressCommon = new AddressCommon(context, resources, telemetry);
        this.addressFormat = new AddressFormat(
            this.countryRegions,
            new AddressMetaData({ ...resources }, this._getAddressFormatExcludeList()),
            this.addressPurposes
        );
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        this.isCheckoutBillingAddress = false;

        // This.addRenderRef = React.createRef();
    }

    public async componentDidMount(): Promise<void> {
        const {
            context: {
                telemetry,
                actionContext: {
                    requestContext: { channel }
                }
            },
            config: { autoSuggestionEnabled, autoSuggestOptions }
        } = this.props;

        // Initializing data props
        this._dataInitialize(this.props);

        this.props.data.checkout.then(() => {
            this._setDefaultCountryRegionId();
            this._initModuleState();
        });

        reaction(
            () => this.countryRegionId,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.currentOperation,
            () => {
                this._getStateProvinces();
            }
        );

        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress,
            shippingAddress => {
                if (this.props.moduleState.isUpdating) {
                    if (shippingAddress && this.isBillingAddressSameAsShipping) {
                        this.isBillingAddressSameAsShipping = true;
                        this._updateCurrentOperation(AddressOperation.Show, shippingAddress);
                    } else if (shippingAddress && this.isBillingAddressSameAsShipping) {
                        this._updateCurrentOperation(AddressOperation.Show, shippingAddress);
                    }
                }
            }
        );

        reaction(
            () => this.isBillingAddressRequried,
            isBillingAddressRequried => {
                if (isBillingAddressRequried) {
                    if (this.props.moduleState.isDisabled) {
                        this.onEdit();
                    }
                } else {
                    this.props.data.checkout.result?.removeBillingAddress({});
                    this.props.moduleState.onDisable();
                }
            }
        );

        if (autoSuggestionEnabled) {
            if (channel && !channel.BingMapsApiKey) {
                telemetry.error('BingMapsApiKey is missing.');
                return;
            }

            if (channel && !channel.BingMapsEnabled) {
                telemetry.error('Map is disabled from HQ.');
                return;
            }

            const options: IAutoSuggestOptions = { ...autoSuggestOptions };
            this.autoSuggest = new AutoSuggest(
                telemetry,
                options,
                channel?.BingMapsApiKey,
                channel?.ChannelCountryRegionISOCode,
                channel?.DefaultLanguageId
            );

            // Customer doesn't have any address. Then add view will be loaded directly. Code for the same to handle that
            if (
                this.props.data.storeSelectorStateManager.result &&
                (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
            ) {
                await this.autoSuggest._loadMapAPI(await this.props.data.storeSelectorStateManager);
            }

            reaction(
                () =>
                    this.props.data.storeSelectorStateManager.result?.loadMapApi &&
                    (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update),
                async () => {
                    await this.autoSuggest?._loadMapAPI(await this.props.data.storeSelectorStateManager);
                }
            );

            reaction(
                () => this.props.data.storeSelectorStateManager.result?.isMapApiLoaded,
                async () => {
                    await this._attachMapAutoSuggest();
                }
            );
        }
    }

    public async componentDidUpdate(): Promise<void> {
        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            if (this.props.data.storeSelectorStateManager.result?.isMapApiLoaded) {
                await this._attachMapAutoSuggest();
            }
        } else {
            this.autoSuggest?.disposeAutoSuggest();
        }
    }

    public shouldComponentUpdate(
        nextProps: ICustomCheckoutBillingAddressProps<ICustomCheckoutBillingAddressData>,
        nextState: ICheckoutBillingAddressViewState
    ): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        if (!this.isBillingAddressRequried) {
            return null;
        }

        const { resources } = this.props;

        const { renderView, config } = this.props;

        const viewProps = {
            ...this.props,
            currentOperation: this.currentOperation,
            selectedAddress: this.selectedAddress,
            addUpdateAddress: this.addUpdateAddress,
            addressListSelectedAddress: this.addressListSelectedAddress,
            customerAddresses: this.customerAddresses,
            countryRegionId: this.countryRegionId,
            stateProvinceInfo: this.stateProvinceInfo,
            validationError: this.validationError,
            addressActionResponse: this.addressActionResponse,
            className: config.className,
            isUpdating: this.isUpdating,
            hasError: this.hasError,
            viewState: {
                isShowAddress: this.selectedAddress && this.currentOperation === AddressOperation.Show,
                isShowAddresList: this.currentOperation === AddressOperation.List && this.customerAddresses.length > 0,
                isShowAddOrUpdateAddress:
                    this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update,
                isShowSameAsShippingCheckbox: this.isCartContainsItemsForShipping && this.props.moduleState.isUpdating
            },
            CheckoutBillingAddress: {
                moduleProps: this.props,
                className: classnames('ms-checkout-billing-address', config.className)
            },
            heading: <AddressBillingHeading {...{ text: resources.addressBillingAddressHeading }} />,

            sameAsShippingCheckbox: (
                <AddressBillingCheckbox
                    {...{
                        isChecked: this.isBillingAddressSameAsShipping,
                        type: 'checkbox',
                        value: 'true',
                        ariaLabel: resources.addressSameAsShippingAddressAriaLabel,
                        text: resources.addressSameAsShippingAddressText,
                        telemetryContent: this.telemetryContent,
                        onChange: this._onBillingAddressSameAsShippingChange
                    }}
                />
            ),
            showAddress: this._renderShowAddress(),
            showAddressSelect: this._renderSelectAddress(),
            showAddOrUpdateAddress: this._renderAddOrUpdateAddress()
        };

        return renderView(viewProps) as React.ReactElement;
    }

    /**
     * On suggestion selected.
     * @param result - The suggestion result.
     */
    @action
    private readonly _onSuggestionSelected = async (result: Microsoft.Maps.ISuggestionResult): Promise<void> => {
        this._clearAddressFields();
        const address = this.addressFormat.getTranformedAddress(result, this.stateProvinceInfo);
        set(this.addUpdateAddress, { Street: '' });
        set(this.addUpdateAddress, { ZipCode: address.ZipCode });
        set(this.addUpdateAddress, { CountyName: address.CountyName });
        set(this.addUpdateAddress, { City: address.City });
        set(this.addUpdateAddress, { State: address.State });
        set(this.addUpdateAddress, { DistrictName: address.DistrictName });
        set(this.addUpdateAddress, { FullAddress: address.FullAddress });

        // Bing autosuggest put the complete address in the Street input box. Updating the street input box to show only street address.
        setTimeout(() => {
            set(this.addUpdateAddress, { Street: address.Street });
        }, 0);
    };

    /**
     * Clear address fields.
     */
    @action
    private readonly _clearAddressFields = (): void => {
        const addressFormatItem = this.addressFormat.getAddressFormat(
            this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
        );
        addressFormatItem.forEach(format => {
            if (this.addUpdateAddress[format.name] !== undefined && !this.autoSuggest?.excludedAddressFields.includes(format.name)) {
                this.addressFormat[format.name] = '';
            }
        });
        this._clearValidation();
    };

    /**
     * Clear validation.
     */
    @action
    private readonly _clearValidation = (): void => {
        this.validationError = {};
    };

    /**
     * On address update.
     * @param name - Name.
     * @param value - Value.
     */
    private readonly onAddressAddUpdate = (name: string, value: string) => {
        set(this.addUpdateAddress, { [name]: value });
        this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId, name);
    };

    /**
     * Method data initialization.
     * @param props -The checkout address properties.
     */
    private readonly _dataInitialize = (props: IProps): void => {
        const { data } = props;

        reaction(
            () => data.countryRegions.result,
            () => {
                this.countryRegions = data.countryRegions.result ?? [];
            }
        );

        reaction(
            () => data.addressPurposes.result,
            () => {
                this.addressPurposes = data.addressPurposes.result ?? [];
            }
        );

        reaction(
            () => data.countryStates.result,
            () => {
                this.stateProvinceInfo = data.countryStates.result ?? [];
            }
        );
    };

    /**
     * Render add or update address function.
     * @returns - Address add update props.
     */
    private readonly _renderAddOrUpdateAddress = (): IAddressAddUpdateProps => {
        return AddressAddUpdate({
            isUpdating: this.isUpdating,
            resources: this.resources,
            addressType: AddressType.Billing,
            addressFormat: this.addressFormat.getAddressFormat(this.addUpdateAddress.ThreeLetterISORegionName ?? this.countryRegionId),
            currentOperation: this.currentOperation,
            isCheckoutBillingAddress: this.isCheckoutBillingAddress,
            defaultCountryRegionId: this.countryRegionId,
            defaultAddressType: this.defaultAddressType,
            selectedAddress: this.addUpdateAddress,
            validationError: this.validationError,
            addressActionResponse: this.addressActionResponse,
            dropdownDisplayData: this.addressFormat.getPrefilledAddressDropdownData(
                this.resources.addressStateDefaultSelectionText,
                this.stateProvinceInfo
            ),
            telemetryContent: this.telemetryContent,
            onInputChange: this._onAddressAddUpdateInputChange,
            onDropdownChange: this._onAddressAddUpdateDropdownChange,
            hasExternalSubmitGroup: this.props.moduleState.hasExternalSubmitGroup,
            onSave: this._onSubmitAddress,
            onCancel: !this.selectedAddress && !this.addressCommon.isAuthenticatedFlow() ? () => {} : this._resetView
        });
    };

    private _renderShowAddress(): IAddressShowProps | null {
        if (this.selectedAddress) {
            return AddressShow({
                address: this.selectedAddress,
                addressFormat: this.addressFormat.getAddressFormat(this.selectedAddress.ThreeLetterISORegionName ?? ''),
                addressPurposes: this.addressPurposes
            });
        }

        return null;
    }

    /**
     * On country region change function.
     * @param countryRegionId - Country region Id.
     */
    private readonly _onCountryChange = (countryRegionId: string) => {
        this.countryRegionId = countryRegionId;
        const twoLetterIsoRegionName = this.addressFormat.getTwoLetterISORegionName(countryRegionId);
        set(this.addUpdateAddress, { ThreeLetterISORegionName: countryRegionId });
        set(this.addUpdateAddress, { TwoLetterISORegionName: twoLetterIsoRegionName });
        this.autoSuggest?.changeAutoSuggestionCountryCode(twoLetterIsoRegionName);
        this._clearAddressFields();
    };

    /**
     * Method to render select address.
     * @returns Select address props.
     */
    private readonly _renderSelectAddress = (): IAddressSelectProps => {
        return AddressSelect({
            addressFormat: this.addressFormat,
            addresses: this.customerAddresses,
            resources: this.resources,
            addressPurposes: this.addressPurposes,
            selectedAddress: this.addressListSelectedAddress,
            onAddressOptionChange: this._onAddressOptionChange,
            hasExternalSubmitGroup: this.props.moduleState.hasExternalSubmitGroup,
            telemetryContent: this.telemetryContent,
            onAddAddress: this._goToAddAddress,
            onSave: this._onSelectAddress,

            onCancel: !this.selectedAddress ? () => {} : this._resetView
        });
    };

    /**
     * Method gets called on address option change.
     * @param event - To get current option.
     */
    private readonly _onAddressOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const addressRecordId = event.currentTarget.value;
        const selectedAddress = this.customerAddresses.find(address => (address.RecordId || '').toString() === addressRecordId);
        if (selectedAddress) {
            this.addressListSelectedAddress = selectedAddress;
        }
    };

    /**
     * Method get called on select address.
     */
    private readonly _onSelectAddress = () => {
        this._updateCurrentOperation(AddressOperation.Show, this.addressListSelectedAddress);
        this._setBillingAddress(this.addressListSelectedAddress);
        this._updateModuleState();

        const stringBillingAddress: string = JSON.stringify(this.addressListSelectedAddress);
        this._updateAttributeValues('BILLINGADDRESS', stringBillingAddress).catch(error => {
            this.props.telemetry.error(`error in _updateExtensionProps ${error}`);
        });
    };

    /**
     * Method get called on goto add address.
     */
    private readonly _goToAddAddress = () => {
        this.isCheckoutBillingAddress = true;
        this.defaultAddressType = 1;
        this._setDefaultCountryRegionId();
        this._updateCurrentOperation(AddressOperation.Add);
    };

    /**
     * Gets address format for exclude list.
     * @returns - Address item type.
     */
    private readonly _getAddressFormatExcludeList = (): AddressItemType[] => {
        const { config } = this.props;
        const addressFormatExcludeList: AddressItemType[] = [];

        if (!config.showAddressType) {
            addressFormatExcludeList.push(AddressItemType.AddressTypeValue);
        }

        addressFormatExcludeList.push(AddressItemType.IsPrimary);

        return addressFormatExcludeList;
    };

    /**
     * Attach map auto suggest.
     */
    private readonly _attachMapAutoSuggest = async (): Promise<void> => {
        const {
            data: {
                storeSelectorStateManager: { result: storeSelectorStateManager }
            }
        } = this.props;

        if (storeSelectorStateManager?.isMapApiLoaded) {
            this.autoSuggest?.attachAutoSuggest('#billing_addressstreet', '#billing_addressstreet_container', this._onSuggestionSelected);
        }
    };

    /**
     * On address add update input change.
     * @param event - The event.
     */
    private readonly _onAddressAddUpdateInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
        const value = (event.target.value || '').replace(new RegExp('[<>]', 'gi'), '');
        this.onAddressAddUpdate(event.target.name, value);
    };

    /**
     * On address add update dropdown change.
     * @param event - The event.
     */
    private readonly _onAddressAddUpdateDropdownChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {
        this.onAddressAddUpdate(event.target.name, event.target.value);

        if (event.target.name === AddressItemType[AddressItemType.ThreeLetterISORegionName]) {
            this._onCountryChange(event.target.value);
        }
    };

    /**
     * Gets state provinces.
     */
    private readonly _getStateProvinces = (): void => {
        if (
            !this.countryRegionId ||
            !(this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update)
        ) {
            return;
        }

        this.addressCommon.getStateProvinces(this.countryRegionId).then((result: StateProvinceInfo[]) => {
            const stateInfo = result.some(state => state.StateId === this.addUpdateAddress.State);

            // Reset state if selected state not found in the list.
            if (!stateInfo) {
                set(this.addUpdateAddress, { State: '' });
            }
            this.stateProvinceInfo = result;
        });
    };

    /**
     * Initialize module state.
     */
    private readonly _initModuleState = (): void => {
        this.props.moduleState.init({
            status: this.isBillingAddressRequried ? 'updating' : 'disabled',
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit
        });

        const { billingAddress, isBillingAddressSameAsShippingAddress } = this.props.data.checkout.result ?? {};
        const isAuthenticated = this.addressCommon.isAuthenticatedFlow();

        const billing =
            this.props.data.checkout.result &&
            this.props.data.checkout.result.checkoutCart &&
            this.props.data.checkout.result.checkoutCart.cart &&
            this.props.data.checkout.result.checkoutCart.cart?.AttributeValues?.find(address => address.Name === 'BILLINGADDRESS');

        if (billing) {
            // @ts-expect-error -- Need to provide data type.
            billingAddress = JSON.parse(billing?.TextValue);
        }

        if (this.isBillingAddressRequried) {
            if (billingAddress) {
                this.isBillingAddressSameAsShipping = isBillingAddressSameAsShippingAddress ?? false;
                if (isAuthenticated) {
                    this._updateCurrentOperation(AddressOperation.List, billingAddress);
                } else {
                    this._updateCurrentOperation(AddressOperation.Show, billingAddress);
                }
                this._updateModuleState();
            } else if (this.isCartContainsItemsForShipping) {
                if (isAuthenticated) {
                    if (this.customerAddresses.length > 0) {
                        this._updateCurrentOperation(AddressOperation.List, this.customerAddresses[0]);
                    } else {
                        this.isBillingAddressSameAsShipping = true;
                        this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
                    }
                } else {
                    this.isBillingAddressSameAsShipping = true;
                    this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
                }
            } else {
                this.isBillingAddressSameAsShipping = false;
                this._updateCurrentOperation(AddressOperation.Add);
            }
        }
    };

    /**
     * Sets default country region Id.
     */
    private _setDefaultCountryRegionId(): void {
        const { request } = this.props.context;
        const market = request.channel?.ChannelCountryRegionISOCode;

        this.countryRegionId = this.addressCommon.getDefaultCountryRegionId(this.countryRegionId, this.countryRegions, market);
    }

    /**
     * On change - Billing address same as shipping.
     * @param event - The event.
     */
    private readonly _onBillingAddressSameAsShippingChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.isBillingAddressSameAsShipping = event.currentTarget.checked;
        const isAuthenticated = this.addressCommon.isAuthenticatedFlow();

        if (this.isBillingAddressSameAsShipping && this.shippingAddress) {
            this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        } else {
            if (isAuthenticated) {
                if (Object.keys(this.addressListSelectedAddress).length > 0) {
                    this._updateCurrentOperation(AddressOperation.List, this.addressListSelectedAddress);
                } else if (this.customerAddresses.length > 0) {
                    this._updateCurrentOperation(AddressOperation.List, this.customerAddresses[0]);
                } else {
                    this.isCheckoutBillingAddress = true;
                    this.defaultAddressType = 1;
                    this._updateCurrentOperation(AddressOperation.Add, this.billingAddress);
                }
            } else {
                this.isCheckoutBillingAddress = true;
                this.defaultAddressType = 1;
                this._updateCurrentOperation(AddressOperation.Add, this.billingAddress);
            }
        }
    };

    @computed private get isCartContainsItemsForShipping(): boolean {
        const { request } = this.props.context;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const { channelDeliveryOptionConfig, featureState } = this.props.data;
        const retailMultiplePickUpOptionEnabled = featureState.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        const pickupDeliveryModeCode = request.channel?.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request.channel?.EmailDeliveryModeCode;

        // If hasInvoiceLine is true, there are only invoices no items in cart and return false here
        return this.props.data.checkout.result?.checkoutCart.hasInvoiceLine
            ? false
            : retailMultiplePickUpOptionEnabled
            ? ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !==
                            channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.find(
                                deliveryMode => deliveryMode === cartLine.DeliveryMode
                            ) && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              )
            : ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).some(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              );
    }

    @computed private get billingAddress(): Address | undefined {
        return this.props.data.checkout.result?.billingAddress;
    }

    @computed private get shippingAddress(): Address | undefined {
        return this.props.data.checkout.result?.shippingAddress;
    }

    @computed private get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState?.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }

    @computed private get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            return count + (giftCard.Balance || 0);
        }, 0);
    }

    @computed private get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        const defaultAmount = 0;

        return checkoutState?.customerAccountAmount ?? defaultAmount;
    }

    @computed private get shouldPaidByCard(): boolean {
        const {
            data: { checkout },
            config
        } = this.props;
        if (!checkout.result) {
            return false;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || cart.CartLines.length === 0) {
            return false;
        }

        const { paymentTenderType, tokenizedPaymentCard } = checkoutResult;
        const isPaidByOtherPaymentSource = config.paymenTenderType !== paymentTenderType && tokenizedPaymentCard;

        // Use payment card when it is not free or gift card balance + Loyalty amount can not cover the total amount
        const amountDue = (cart.TotalAmount || 0) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;

        return amountDue > 0 && !isPaidByOtherPaymentSource;
    }

    @computed private get isBillingAddressRequried(): boolean {
        return this.shouldPaidByCard;
    }

    /**
     * Method get called on add/update success.
     * @param response - Retail api response.
     */
    private readonly _onAddOrUpdateSuccess = (response: IAddressResponse) => {
        if (response.customerAddresses) {
            this.customerAddresses = response.customerAddresses.filter(address => address.AddressTypeValue === 1);
        }

        if (response.address) {
            this._updateCurrentOperation(AddressOperation.Show, response.address);
            this._setBillingAddress(response.address);
            this._updateModuleState();
        }
    };

    /**
     * On submit address.
     */
    private readonly _onSubmitAddress = (): void => {
        if (!this.addressFormat.validateAddressFormat(this.addUpdateAddress, this.validationError, this.countryRegionId)) {
            this.props.moduleState.setHasError(true);
            return;
        }

        let billingAddress: Address = {};
        set(this.addUpdateAddress, { AddressTypeValue: 1 });

        let response: Promise<IAddressResponse>;
        if (this.addressCommon.isAuthenticatedFlow()) {
            response =
                this.currentOperation === AddressOperation.Update
                    ? this.addressCommon.updateCustomerAddress(this.addUpdateAddress)
                    : this.addressCommon.addCustomerAddress(this.addUpdateAddress);
        } else {
            response = Promise.resolve({ address: this.addUpdateAddress });
        }

        this.isUpdating = true;
        this._updateModuleState();

        response
            .then(
                (result: IAddressResponse) => {
                    this.isUpdating = false;

                    let newAddress = result.address;
                    newAddress = { ...newAddress, ...this.addUpdateAddress };

                    if (result.address) {
                        billingAddress = result.address;
                        this.hasError = false;
                        if (result.customerAddresses) {
                            this._onAddOrUpdateSuccess({ customerAddresses: result.customerAddresses, address: newAddress });
                        } else {
                            this._onAddOrUpdateSuccess({ address: newAddress });
                        }
                    } else {
                        this.hasError = true;
                        this.addressActionResponse = result;
                        this._updateModuleState();
                    }
                },
                () => {
                    this.hasError = true;
                    this.isUpdating = false;
                    this._updateModuleState();
                }
            )
            .then(() => {
                const stringBillingAddress: string = JSON.stringify(billingAddress);
                this._updateAttributeValues('c', stringBillingAddress).catch(error => {
                    this.props.telemetry.error(`error in _updateExtensionProps ${error}`);
                });
            });
    };

    private readonly _addShippingAddress = (shippingAddress: Address): void => {
        set(shippingAddress, { AddressTypeValue: 1 });
        let response: Promise<IAddressResponse>;
        let billingAddress: Address = {};
        if (this.addressCommon.isAuthenticatedFlow()) {
            this.customerAddresses.map((address: Address) => {
                if (address.RecordId === shippingAddress.RecordId) {
                    billingAddress = shippingAddress;
                } else if (
                    address.Name === shippingAddress.Name &&
                    address.Phone === shippingAddress.Phone &&
                    address.Street === shippingAddress.Street &&
                    address.City === shippingAddress.City &&
                    address.State === shippingAddress.State &&
                    address.ZipCode === shippingAddress.ZipCode &&
                    address.ThreeLetterISORegionName === shippingAddress.ThreeLetterISORegionName
                ) {
                    billingAddress = shippingAddress;
                }
            });
            if (!billingAddress.Name) {
                const newAddress: Address = {
                    AddressTypeValue: 1,
                    City: shippingAddress.City,
                    Phone: shippingAddress.Phone,
                    Name: shippingAddress.Name,
                    Street: shippingAddress.Street,
                    State: shippingAddress.State,
                    ThreeLetterISORegionName: shippingAddress.ThreeLetterISORegionName,
                    ZipCode: shippingAddress.ZipCode
                };

                response =
                    this.currentOperation === AddressOperation.Update
                        ? this.addressCommon.updateCustomerAddress(newAddress)
                        : this.addressCommon.addCustomerAddress(newAddress);
            } else {
                response = Promise.resolve({ address: billingAddress });
            }
        } else {
            response = Promise.resolve({ address: shippingAddress });
        }

        this.isUpdating = true;

        response
            .then(
                (result: IAddressResponse) => {
                    this.isUpdating = false;

                    const newAddress = result.address;
                    if (result.address) {
                        billingAddress = result.address;
                        this.hasError = false;
                        if (result.customerAddresses) {
                            this._onAddOrUpdateSuccess({ customerAddresses: result.customerAddresses, address: newAddress });
                        } else {
                            this._onAddOrUpdateSuccess({ address: newAddress });
                        }

                        this._updateModuleState();
                    } else {
                        this.hasError = true;
                        this.addressActionResponse = result;
                        this._updateModuleState();
                    }
                },
                () => {
                    this.hasError = true;
                    this.isUpdating = false;
                    this._updateModuleState();
                }
            )
            .then(() => {
                const stringBillingAddress: string = JSON.stringify(
                    this.addressCommon.isAuthenticatedFlow() ? billingAddress : shippingAddress
                );
                this._updateAttributeValues('BILLINGADDRESS', stringBillingAddress).catch(error => {
                    this.props.telemetry.error(`error in _updateExtensionProps ${error}`);
                });
            });
    };

    private readonly _updateAttributeValues = async (attributekey: string, value: string) => {
        await this.props.data.checkout.result?.checkoutCart.updateAttributeValues({
            newAttributeValues: [
                {
                    // @ts-expect-error -- Need to provide data type.
                    '@odata.type': '#Microsoft.Dynamics.Commerce.Runtime.DataModel.AttributeTextValue',
                    Name: attributekey,
                    TextValue: value,
                    ExtensionProperties: [],
                    TextValueTranslations: []
                }
            ]
        });
    };

    /**
     * On submit.
     */
    private readonly onSubmit = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this._onSubmitAddress();
                break;
            case AddressOperation.Show:
                if (this.selectedAddress) {
                    if (this.isBillingAddressSameAsShipping) {
                        this._addShippingAddress(this.selectedAddress);
                    }
                    this._setBillingAddress(this.selectedAddress);
                    this._updateCurrentOperation(AddressOperation.Show, this.selectedAddress);
                    this._updateModuleState();
                }
                break;
            case AddressOperation.List:
                this._onSelectAddress();
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * On cancel.
     */
    private readonly onCancel = (): void => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                // this._resetView();
                this._clearAddressFields();
                if (!(!this.selectedAddress && !this.addressCommon.isAuthenticatedFlow())) {
                    this._resetView();
                }
                break;
            case AddressOperation.Show:
                if (this.selectedAddress) {
                    this._resetView();
                }
                break;
            default:
                this.props.telemetry.error('Invalid operation');
        }
    };

    /**
     * On edit.
     */
    private readonly onEdit = (): void => {
        if (this.isBillingAddressSameAsShipping && this.shippingAddress && this.isCartContainsItemsForShipping) {
            this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        } else {
            // this._updateCurrentOperation(AddressOperation.Add, this.billingAddress);
            if (this.addressCommon.isAuthenticatedFlow() && this.billingAddress) {
                this._updateCurrentOperation(AddressOperation.List, this.billingAddress);
            } else if (this.billingAddress) {
                this._updateCurrentOperation(AddressOperation.Update, this.billingAddress);
            }
        }
        this.props.moduleState.onUpdating();
    };

    /**
     * Sets billing address.
     * @param address - The address.
     */
    private readonly _setBillingAddress = (address: Address): void => {
        if (this.props.data.checkout.result) {
            const newBillingAddress = { ...address };

            if (address.ThreeLetterISORegionName && !newBillingAddress.TwoLetterISORegionName) {
                newBillingAddress.TwoLetterISORegionName = this.addressFormat.getTwoLetterISORegionName(address.ThreeLetterISORegionName);
            }

            this.props.data.checkout.result.updateBillingAddress({
                newBillingAddress,
                additionalProperties: {
                    isBillingAddressSameAsShippingAddress: this.isBillingAddressSameAsShipping
                }
            });
        }
    };

    /**
     * Reset view.
     */
    private readonly _resetView = () => {
        switch (this.currentOperation) {
            case AddressOperation.Add:
            case AddressOperation.Update:
                this._updateCurrentOperation(
                    this.addressCommon.isAuthenticatedFlow() ? AddressOperation.List : AddressOperation.Show,
                    this.billingAddress
                );
                break;
            default:
                this._updateCurrentOperation(AddressOperation.Show, this.shippingAddress);
        }
        this._updateModuleState();
    };

    /**
     * Update current operation.
     * @param operation - Address operation
     * @param selectedAddress - The selected address.
     */
    private readonly _updateCurrentOperation = (operation: AddressOperation, selectedAddress?: Address) => {
        this.currentOperation = operation;
        this.selectedAddress = selectedAddress;

        if (this.currentOperation === AddressOperation.Add || this.currentOperation === AddressOperation.Update) {
            this.addUpdateAddress = { ...this.selectedAddress } || {};
            set(this.addUpdateAddress, {
                ThreeLetterISORegionName: this.addUpdateAddress.ThreeLetterISORegionName || this.countryRegionId
            });
            set(this.addUpdateAddress, { AddressTypeValue: this.addUpdateAddress.AddressTypeValue || this.defaultAddressType });
        } else if (this.currentOperation === AddressOperation.List) {
            this.addressListSelectedAddress = { ...this.selectedAddress } || {};
        }
    };

    /**
     * Updates the module state.
     */
    private readonly _updateModuleState = () => {
        if (this.currentOperation === AddressOperation.Show) {
            this.props.moduleState.onReady();
        } else if (this.isUpdating) {
            this.props.moduleState.onPending();
        } else {
            this.props.moduleState.onUpdating();
        }
    };
}

export default CheckoutBillingAddress;
